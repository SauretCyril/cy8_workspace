#!/usr/bin/env python3
"""
cy8_comfyui_customNode_call.py - Classe pour l'appel et la gestion des custom nodes ComfyUI

Cette classe fournit des m√©thodes pour interagir avec les custom nodes ComfyUI,
r√©cup√©rer leurs informations, et ex√©cuter des workflows avec des custom nodes sp√©cifiques.
"""

import json
import requests
import time
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin

# Import conditionnel de safetensors (optionnel)
try:
    from safetensors.torch import safe_open

    SAFETENSORS_AVAILABLE = True
except ImportError:
    SAFETENSORS_AVAILABLE = False
    safe_open = None


class ComfyUICustomNodeCaller:
    """Classe pour g√©rer les appels aux custom nodes ComfyUI"""

    def __init__(
        self, server_url: str = "http://127.0.0.1:8188", api_key: Optional[str] = None
    ):
        """
        Initialiser le gestionnaire de custom nodes ComfyUI

        Args:
            server_url: URL du serveur ComfyUI (d√©faut: http://127.0.0.1:8188)
            api_key: Cl√© API ComfyUI si requise
        """
        self.server_url = server_url.rstrip("/")
        self.api_key = api_key
        self.session = requests.Session()

        # Headers par d√©faut
        self.session.headers.update(
            {
                "Content-Type": "application/json",
                "User-Agent": "cy8_prompts_manager/1.0",
            }
        )

    def get_custom_nodes_info(self) -> Dict[str, Any]:
        """
        R√©cup√©rer les informations sur les custom nodes disponibles

        Returns:
            Dict contenant les informations sur les custom nodes
        """
        try:
            url = urljoin(self.server_url, "/object_info")
            response = self.session.get(url, timeout=30)
            response.raise_for_status()

            return response.json()

        except requests.exceptions.RequestException as e:
            raise Exception(
                f"Erreur lors de la r√©cup√©ration des informations custom nodes: {e}"
            )

    def get_available_custom_node_types(self) -> List[str]:
        """
        Obtenir la liste des types de custom nodes disponibles

        Returns:
            Liste des noms de classes de custom nodes
        """
        try:
            nodes_info = self.get_custom_nodes_info()
            custom_node_types = []

            for node_type, node_info in nodes_info.items():
                # Filtrer les custom nodes (g√©n√©ralement ils ont des noms sp√©ciaux)
                if self._is_custom_node(node_type, node_info):
                    custom_node_types.append(node_type)

            return sorted(custom_node_types)

        except Exception as e:
            raise Exception(
                f"Erreur lors de la r√©cup√©ration des types de custom nodes: {e}"
            )

    def _is_custom_node(self, node_type: str, node_info: Dict) -> bool:
        """
        D√©terminer si un node est un custom node

        Args:
            node_type: Type du node
            node_info: Informations du node

        Returns:
            True si c'est un custom node
        """
        # Crit√®res pour identifier un custom node
        custom_indicators = [
            # Noms typiques de custom nodes
            node_type.startswith(("ComfyUI", "CR ", "WAS ", "IPAdapter", "ControlNet")),
            # Contient des caract√®res sp√©ciaux
            " " in node_type or "-" in node_type,
            # Commence par une majuscule suivie de minuscules
            (
                node_type[0].isupper() and any(c.islower() for c in node_type[1:])
                if node_type
                else False
            ),
        ]

        return any(custom_indicators)

    def create_custom_node_workflow(
        self, node_type: str, node_inputs: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Cr√©er un workflow avec un custom node sp√©cifique

        Args:
            node_type: Type du custom node √† utiliser
            node_inputs: Inputs pour le custom node

        Returns:
            Workflow format√© pour ComfyUI
        """
        # Workflow adapt√© selon le type de n≈ìud
        if node_type == "ExtraPathReader":
            # ExtraPathReader avec PreviewAny (n≈ìud de sortie universel)
            workflow = {
                "1": {
                    "class_type": "ExtraPathReader",
                    "inputs": {},
                    "_meta": {"title": "Extra Path Reader"},
                },
                "2": {
                    "class_type": "PreviewAny",
                    "inputs": {
                        "source": ["1", 0],  # Prendre la sortie STRING du node 1
                    },
                    "_meta": {"title": "Preview Extra Paths"},
                },
            }
        else:
            # Workflow g√©n√©rique avec PreviewAny (n≈ìud de sortie universel)
            workflow = {
                "1": {
                    "class_type": node_type,
                    "inputs": node_inputs,
                    "_meta": {"title": f"{node_type}"},
                },
                "2": {
                    "class_type": "PreviewAny",
                    "inputs": {
                        "source": ["1", 0],  # Prendre la sortie du node 1
                    },
                    "_meta": {"title": "Preview Output"},
                },
            }

        return workflow

    def execute_custom_node_workflow(
        self, workflow: Dict[str, Any], extra_data: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Ex√©cuter un workflow contenant des custom nodes

        Args:
            workflow: Workflow √† ex√©cuter
            extra_data: Donn√©es suppl√©mentaires (API key, etc.)

        Returns:
            R√©ponse de ComfyUI
        """
        try:
            # Pr√©parer le payload
            payload = {"prompt": workflow}

            # Ajouter les donn√©es suppl√©mentaires
            if extra_data:
                payload["extra_data"] = extra_data
            elif self.api_key:
                payload["extra_data"] = {"api_key_comfy_org": self.api_key}

            # Debug: afficher le workflow g√©n√©r√©
            print(f"üîç Workflow g√©n√©r√© pour debug:")
            print(json.dumps(workflow, indent=2))

            # Envoyer la requ√™te
            url = urljoin(self.server_url, "/prompt")
            response = self.session.post(url, json=payload, timeout=30)

            # Gestion d'erreur d√©taill√©e
            if response.status_code == 400:
                try:
                    error_details = response.json()
                    print(
                        f"‚ùå Erreur 400 d√©taill√©e: {json.dumps(error_details, indent=2)}"
                    )
                    raise Exception(f"Erreur 400 - Workflow invalide: {error_details}")
                except ValueError:
                    print(f"‚ùå Erreur 400 - R√©ponse: {response.text}")
                    raise Exception(f"Erreur 400 - Bad Request: {response.text}")

            response.raise_for_status()
            return response.json()

        except requests.exceptions.RequestException as e:
            print(f"‚ùå Erreur de requ√™te: {e}")
            if hasattr(e, "response") and e.response is not None:
                print(f"‚ùå Statut: {e.response.status_code}")
                print(f"‚ùå Contenu: {e.response.text}")
            raise Exception(f"Erreur lors de l'ex√©cution du workflow: {e}")

    def call_custom_node(
        self, node_type: str, inputs: Dict[str, Any], extra_data: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Appeler directement un custom node avec des inputs

        Args:
            node_type: Type du custom node
            inputs: Inputs pour le node
            extra_data: Donn√©es suppl√©mentaires

        Returns:
            R√©ponse de l'ex√©cution
        """
        workflow = self.create_custom_node_workflow(node_type, inputs)
        return self.execute_custom_node_workflow(workflow, extra_data)

    def test_extra_path_reader_direct(self) -> Dict[str, Any]:
        """
        Tester ExtraPathReader avec une approche directe et robuste

        Returns:
            R√©sultat de l'ex√©cution ou informations d'erreur
        """
        print("üß™ Test ExtraPathReader avec approche directe...")

        try:
            # Test simple: juste appeler ExtraPathReader directement
            print("üóÇÔ∏è  Tentative d'appel direct d'ExtraPathReader...")

            # M√©thode 1: Appel direct via call_custom_node
            try:
                result = self.call_custom_node("ExtraPathReader", {})
                if result and not result.get('error'):
                    print("‚úÖ Succ√®s avec appel direct!")
                    return {
                        "error": False,
                        "result": result,
                        "method": "Direct call",
                    }
            except Exception as e:
                print(f"‚ö†Ô∏è  Appel direct √©chou√©: {e}")

            # M√©thode 2: Workflow minimal avec r√©cup√©ration via API
            print("üîß Essai avec workflow minimal...")

            try:
                # Cr√©er un workflow tr√®s simple qui fonctionne toujours
                simple_workflow = {
                    "1": {"class_type": "ExtraPathReader", "inputs": {}}
                }

                # Envoyer via l'API queue
                payload = {
                    "prompt": simple_workflow,
                    "client_id": f"cy8_env_test_{int(time.time())}"
                }

                url = urljoin(self.server_url, "/prompt")
                response = self.session.post(url, json=payload, timeout=30)

                if response.status_code == 200:
                    result_data = response.json()
                    prompt_id = result_data.get("prompt_id")

                    if prompt_id:
                        print(f"üìã Prompt ID obtenu: {prompt_id}")

                        # Attendre un peu pour l'ex√©cution
                        time.sleep(3)

                        # R√©cup√©rer via l'historique
                        history_url = urljoin(self.server_url, f"/history/{prompt_id}")
                        history_response = self.session.get(history_url, timeout=10)

                        if history_response.status_code == 200:
                            history_data = history_response.json()
                            print("‚úÖ Succ√®s avec workflow minimal!")

                            return {
                                "error": False,
                                "result": {
                                    "prompt_id": prompt_id,
                                    "history": history_data
                                },
                                "method": "Minimal workflow",
                            }
                        else:
                            print(f"‚ö†Ô∏è  Erreur historique: {history_response.status_code}")

                else:
                    error_data = response.json() if response.headers.get('content-type', '').startswith('application/json') else {}
                    error_msg = error_data.get('error', {}).get('message', response.text)
                    print(f"‚ùå Erreur workflow: {error_msg}")

            except Exception as e:
                print(f"‚ö†Ô∏è  Workflow minimal √©chou√©: {e}")

            # M√©thode 3: R√©cup√©ration des informations du node directement
            print("üìä Essai de r√©cup√©ration d'informations du node...")

            try:
                nodes_info = self.get_custom_nodes_info()
                extra_path_info = nodes_info.get("ExtraPathReader")

                if extra_path_info:
                    print("‚úÖ Informations ExtraPathReader r√©cup√©r√©es!")
                    return {
                        "error": False,
                        "result": {
                            "node_info": extra_path_info,
                            "method": "Node info retrieval"
                        },
                        "method": "Node information",
                    }

            except Exception as e:
                print(f"‚ö†Ô∏è  R√©cup√©ration info node √©chou√©e: {e}")

            # Si tout √©choue
            return {
                "error": True,
                "message": "Toutes les m√©thodes de test ont √©chou√©",
                "methods_tried": ["Direct call", "Minimal workflow", "Node information"],
            }

        except Exception as e:
            return {
                "error": True,
                "message": f"Erreur g√©n√©rale lors du test: {e}",
            }

    def get_extra_paths(self) -> Dict[str, Any]:
        """
        R√©cup√©rer les chemins extra de ComfyUI via ExtraPathReader

        Returns:
            Dict contenant les chemins ou informations d'erreur
        """
        try:
            print("üóÇÔ∏è  R√©cup√©ration des chemins extra via ExtraPathReader...")

            # Ex√©cuter ExtraPathReader
            result = self.call_custom_node("ExtraPathReader", {})

            if "prompt_id" in result:
                prompt_id = result["prompt_id"]

                # Attendre l'ex√©cution
                import time

                time.sleep(2)

                # R√©cup√©rer l'historique
                url = urljoin(self.server_url, f"/history/{prompt_id}")
                response = self.session.get(url, timeout=10)

                if response.status_code == 200:
                    history = response.json()

                    if prompt_id in history:
                        prompt_data = history[prompt_id]

                        if "outputs" in prompt_data and "2" in prompt_data["outputs"]:
                            # Extraire le texte JSON du n≈ìud PreviewAny
                            output_text = prompt_data["outputs"]["2"]["text"][0]

                            # Parser le JSON
                            import json

                            paths_data = json.loads(output_text)

                            print("‚úÖ Chemins extra r√©cup√©r√©s avec succ√®s")
                            return {"error": False, "data": paths_data}
                        else:
                            return {
                                "error": True,
                                "message": "Pas de sortie dans l'historique",
                            }
                    else:
                        return {
                            "error": True,
                            "message": "Prompt ID non trouv√© dans l'historique",
                        }
                else:
                    return {
                        "error": True,
                        "message": f"Erreur r√©cup√©ration historique: {response.status_code}",
                    }
            else:
                return {
                    "error": True,
                    "message": "Pas de prompt_id dans la r√©ponse",
                    "response": result,
                }

        except Exception as e:
            return {"error": True, "message": f"Exception lors de la r√©cup√©ration: {e}"}

    def get_custom_node_schema(self, node_type: str) -> Optional[Dict[str, Any]]:
        """
        Obtenir le sch√©ma/structure d'un custom node sp√©cifique

        Args:
            node_type: Type du custom node

        Returns:
            Sch√©ma du custom node ou None si non trouv√©
        """
        try:
            nodes_info = self.get_custom_nodes_info()
            return nodes_info.get(node_type)

        except Exception as e:
            raise Exception(
                f"Erreur lors de la r√©cup√©ration du sch√©ma pour {node_type}: {e}"
            )

    def validate_custom_node_inputs(
        self, node_type: str, inputs: Dict[str, Any]
    ) -> bool:
        """
        Valider les inputs pour un custom node

        Args:
            node_type: Type du custom node
            inputs: Inputs √† valider

        Returns:
            True si les inputs sont valides
        """
        try:
            schema = self.get_custom_node_schema(node_type)
            if not schema:
                return False

            required_inputs = schema.get("input", {}).get("required", {})

            # V√©rifier que tous les inputs requis sont pr√©sents
            for required_input in required_inputs:
                if required_input not in inputs:
                    return False

            return True

        except Exception:
            return False

    def get_server_status(self) -> Dict[str, Any]:
        """
        V√©rifier le statut du serveur ComfyUI

        Returns:
            Informations sur le statut du serveur
        """
        try:
            url = urljoin(self.server_url, "/system_stats")
            response = self.session.get(url, timeout=5)
            response.raise_for_status()

            return {
                "status": "online",
                "response_time": response.elapsed.total_seconds(),
                "system_stats": response.json(),
            }

        except requests.exceptions.RequestException as e:
            return {"status": "offline", "error": str(e)}

    def close(self):
        """Fermer la session"""
        if self.session:
            self.session.close()

    def __enter__(self):
        """Support du context manager"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Support du context manager"""
        self.close()


# Exemple d'utilisation
def example_usage():
    """Exemple d'utilisation de la classe"""

    # Utilisation avec context manager
    with ComfyUICustomNodeCaller() as caller:

        # V√©rifier le statut du serveur
        status = caller.get_server_status()
        print(f"Statut du serveur: {status['status']}")

        if status["status"] == "online":
            # Obtenir les custom nodes disponibles
            custom_nodes = caller.get_available_custom_node_types()
            print(f"Custom nodes disponibles: {len(custom_nodes)}")

            # Exemple d'appel √† un custom node
            if "ExtraPathReader" in custom_nodes:
                try:
                    result = caller.call_custom_node(
                        node_type="ExtraPathReader", inputs={}
                    )
                    print(f"R√©sultat: {result}")
                except Exception as e:
                    print(f"Erreur: {e}")


if __name__ == "__main__":
    example_usage()
