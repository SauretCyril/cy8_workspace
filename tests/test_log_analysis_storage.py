#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test de stockage des r√©sultats d'analyse de log en base de donn√©es

V√©rifie que lorsqu'on clique sur 'Analyser le log', les r√©sultats
sont bien stock√©s dans la table resultats_analyses de la base de donn√©es.
"""

import sys
import os
import tempfile
import unittest
from unittest.mock import Mock, patch, MagicMock

# Configuration de l'encodage pour Windows
if os.name == "nt":  # Windows
    import codecs

    sys.stdout = codecs.getwriter("utf-8")(sys.stdout.buffer, "strict")
    sys.stderr = codecs.getwriter("utf-8")(sys.stderr.buffer, "strict")

# Ajouter le r√©pertoire src au path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))


def test_log_analysis_storage():
    """Test de stockage des r√©sultats d'analyse en base"""
    print("üß™ Test de stockage des r√©sultats d'analyse de log")
    print("=" * 50)

    try:
        # Import des modules n√©cessaires
        from cy8_database_manager import cy8_database_manager
        from cy8_prompts_manager_main import cy8_prompts_manager
        import tkinter as tk

        # Cr√©er une base de donn√©es temporaire
        temp_db = tempfile.NamedTemporaryFile(suffix=".db", delete=False)
        temp_db_path = temp_db.name
        temp_db.close()

        print(f"üìÅ Base de donn√©es temporaire: {temp_db_path}")

        # Initialiser le gestionnaire de base de donn√©es
        db_manager = cy8_database_manager(temp_db_path)
        db_manager.init_database(mode="dev")

        # Cr√©er l'environnement de test en ins√©rant directement dans la base
        environment_id = "TEST_ENV_001"
        try:
            db_manager.cursor.execute(
                """
                INSERT OR REPLACE INTO environnements
                (id, name, path, description, last_analysis)
                VALUES (?, ?, ?, ?, datetime('now'))
                """,
                (
                    environment_id,
                    "Test Environment",
                    "/test/comfyui",
                    "Environment for testing",
                ),
            )
            db_manager.conn.commit()
        except Exception as e:
            print(f"Erreur lors de la cr√©ation de l'environnement: {e}")
            return False

        print(f"üåç Environnement cr√©√©: {environment_id}")

        # Cr√©er l'application (sans interface graphique)
        root = tk.Tk()
        root.withdraw()

        app = cy8_prompts_manager()
        app.root = root
        app.db_manager = db_manager
        app.current_environment_id = environment_id

        # Mock du log analyzer pour simuler des r√©sultats
        mock_log_analyzer = Mock()
        mock_entries = [
            {
                "timestamp": "2024-10-03 10:30:00",
                "type": "error",
                "category": "custom_node",
                "element": "test_node",
                "message": "Node test_node failed to load",
                "line": "42",
            },
            {
                "timestamp": "2024-10-03 10:30:01",
                "type": "info",
                "category": "system",
                "element": "comfyui",
                "message": "ComfyUI started successfully",
                "line": "1",
            },
            {
                "timestamp": "2024-10-03 10:30:02",
                "type": "warning",
                "category": "model",
                "element": "checkpoint",
                "message": "Model checkpoint not found",
                "line": "100",
            },
        ]

        mock_result = {
            "success": True,
            "entries": mock_entries,
            "summary": {
                "custom_nodes_ok": 1,
                "custom_nodes_failed": 1,
                "errors": 1,
                "warnings": 1,
                "info_messages": 1,
            },
            "config_id": "TEST_CONFIG",
        }

        mock_log_analyzer.analyze_log_file.return_value = mock_result
        mock_log_analyzer.get_summary_text.return_value = "Test summary"

        app.log_analyzer = mock_log_analyzer

        # Mock des √©l√©ments UI n√©cessaires
        app.comfyui_log_path = Mock()
        app.comfyui_log_path.get.return_value = "/test/log/comfyui.log"

        app.analyze_log_btn = Mock()
        app.log_status_label = Mock()
        app.log_results_tree = Mock()
        app.log_results_tree.get_children.return_value = []
        app.log_results_tree.insert = Mock()

        app.log_results_count_label = Mock()
        app.comfyui_config_id = Mock()
        app.comfyui_config_id.get.return_value = ""
        app.comfyui_config_id.set = Mock()

        app.config_info_label = Mock()
        app.root.update = Mock()

        print("üîß Mocks configur√©s")

        # V√©rifier qu'il n'y a pas de r√©sultats initialement
        initial_results = db_manager.get_analysis_results(environment_id)
        print(f"üìä R√©sultats initiaux: {len(initial_results)}")

        # Mock de messagebox pour √©viter les popups
        with patch("tkinter.messagebox.showinfo"), patch(
            "os.path.exists", return_value=True
        ):

            # Ex√©cuter l'analyse de log
            print("üöÄ Lancement de l'analyse de log...")
            app.analyze_comfyui_log()

        # V√©rifier que les r√©sultats ont √©t√© stock√©s
        stored_results = db_manager.get_analysis_results(environment_id)
        print(f"üíæ R√©sultats stock√©s: {len(stored_results)}")

        # Tests de validation
        tests_passed = 0
        total_tests = 4

        # Test 1: Nombre de r√©sultats stock√©s
        if len(stored_results) == len(mock_entries):
            print("‚úÖ Test 1: Nombre correct de r√©sultats stock√©s")
            tests_passed += 1
        else:
            print(
                f"‚ùå Test 1: Attendu {len(mock_entries)}, obtenu {len(stored_results)}"
            )

        # Test 2: V√©rification du contenu des r√©sultats
        if stored_results:
            first_result = stored_results[0]
            # Format: (id, environment_id, fichier, type, niveau, message, details, timestamp)

            if first_result[1] == environment_id:
                print("‚úÖ Test 2: Environment ID correct")
                tests_passed += 1
            else:
                print(f"‚ùå Test 2: Environment ID incorrect: {first_result[1]}")
        else:
            print("‚ùå Test 2: Aucun r√©sultat √† v√©rifier")

        # Test 3: V√©rification des types de r√©sultats
        stored_types = {
            result[3] for result in stored_results
        }  # type est en position 3
        expected_types = {entry["type"] for entry in mock_entries}

        if stored_types == expected_types:
            print("‚úÖ Test 3: Types de r√©sultats corrects")
            tests_passed += 1
        else:
            print(
                f"‚ùå Test 3: Types incorrects. Attendu: {expected_types}, Obtenu: {stored_types}"
            )

        # Test 4: V√©rification que log_analyzer a √©t√© appel√©
        if mock_log_analyzer.analyze_log_file.called:
            print("‚úÖ Test 4: Log analyzer appel√©")
            tests_passed += 1
        else:
            print("‚ùå Test 4: Log analyzer non appel√©")

        # Afficher quelques d√©tails des r√©sultats stock√©s
        print(f"\nüìã D√©tails des r√©sultats stock√©s:")
        for i, result in enumerate(stored_results[:3]):  # Afficher les 3 premiers
            print(
                f"   {i+1}. Type: {result[3]}, Niveau: {result[4]}, Message: {result[5][:50]}..."
            )

        # Nettoyage
        root.destroy()
        db_manager.close()
        os.unlink(temp_db_path)

        # R√©sum√©
        print(f"\nüéØ R√âSUM√â:")
        print(f"   Tests r√©ussis: {tests_passed}/{total_tests}")
        print(f"   Taux de r√©ussite: {(tests_passed/total_tests)*100:.1f}%")

        if tests_passed == total_tests:
            print("\nüèÜ STOCKAGE FONCTIONNEL !")
            print("‚úÖ Les r√©sultats d'analyse sont bien stock√©s en base")
            print("‚úÖ Le mapping des donn√©es est correct")
            print("‚úÖ L'environnement est associ√© correctement")
            return True
        else:
            print("\n‚ùå PROBL√àMES D√âTECT√âS")
            return False

    except Exception as e:
        print(f"‚ùå Erreur lors du test: {e}")
        import traceback

        traceback.print_exc()
        return False


def test_database_methods():
    """Test des m√©thodes de la base de donn√©es pour les analyses"""
    print("\nüóÑÔ∏è Test des m√©thodes de base de donn√©es...")

    try:
        from cy8_database_manager import cy8_database_manager

        # Cr√©er une base temporaire
        temp_db = tempfile.NamedTemporaryFile(suffix=".db", delete=False)
        temp_db_path = temp_db.name
        temp_db.close()

        db_manager = cy8_database_manager(temp_db_path)
        db_manager.init_database(mode="dev")

        environment_id = "TEST_ENV_DB"

        # Test d'ajout de r√©sultat
        success = db_manager.add_analysis_result(
            environment_id=environment_id,
            fichier="test.log",
            type_result="error",
            niveau="critical",
            message="Test error message",
            details="Test details",
        )

        if success:
            print("‚úÖ Ajout de r√©sultat d'analyse r√©ussi")
        else:
            print("‚ùå √âchec de l'ajout de r√©sultat")
            return False

        # Test de r√©cup√©ration
        results = db_manager.get_analysis_results(environment_id)

        if len(results) == 1:
            print("‚úÖ R√©cup√©ration de r√©sultats r√©ussie")
        else:
            print(f"‚ùå R√©cup√©ration incorrecte: {len(results)} r√©sultats")
            return False

        # Test de nettoyage
        db_manager.clear_analysis_results(environment_id)
        results_after_clear = db_manager.get_analysis_results(environment_id)

        if len(results_after_clear) == 0:
            print("‚úÖ Nettoyage des r√©sultats r√©ussi")
        else:
            print(f"‚ùå Nettoyage √©chou√©: {len(results_after_clear)} r√©sultats restants")
            return False

        # Nettoyage
        db_manager.close()
        os.unlink(temp_db_path)

        return True

    except Exception as e:
        print(f"‚ùå Erreur lors du test de base: {e}")
        return False


def main():
    """Fonction principale de test"""
    print("üöÄ Test complet de stockage des analyses de log")
    print("=" * 50)

    success_count = 0
    total_tests = 2

    # Test 1: M√©thodes de base de donn√©es
    if test_database_methods():
        success_count += 1
        print("‚úÖ Test 1 R√âUSSI - M√©thodes de base")
    else:
        print("‚ùå Test 1 √âCHOU√â")

    # Test 2: Stockage complet
    if test_log_analysis_storage():
        success_count += 1
        print("‚úÖ Test 2 R√âUSSI - Stockage complet")
    else:
        print("‚ùå Test 2 √âCHOU√â")

    # R√©sum√© final
    print(f"\nüéØ R√âSUM√â FINAL:")
    print(f"   Tests r√©ussis: {success_count}/{total_tests}")
    print(f"   Taux de r√©ussite: {(success_count/total_tests)*100:.1f}%")

    if success_count == total_tests:
        print("\nüéâ FONCTIONNALIT√â VALID√âE !")
        print("‚úÖ Les r√©sultats d'analyse de log sont stock√©s en base")
        print("‚úÖ Le tableau et la base sont synchronis√©s")
        print("‚úÖ L'association avec l'environnement fonctionne")
        print("\nüí° Maintenant, quand vous cliquez sur 'Analyser le log',")
        print("   les r√©sultats sont automatiquement sauvegard√©s !")
        return True
    else:
        print("\n‚ùå PROBL√àMES D√âTECT√âS")
        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
